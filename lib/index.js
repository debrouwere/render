// Generated by CoffeeScript 1.9.1
(function() {
  var PathExp, _, async, colors, context, describe, groupby, render, timing, unwrap, utils;

  _ = {
    defaults: require('lodash.defaults'),
    pluck: require('lodash.pluck'),
    pairs: require('lodash.pairs'),
    pick: require('lodash.pick'),
    extend: require('lodash.assignin'),
    partial: require('lodash.partial'),
    countBy: require('lodash.countby'),
    identity: require('lodash.identity')
  };

  async = require('async');

  colors = require('colors');

  PathExp = require('simple-path-expressions').PathExp;

  groupby = require('groupby-cli');

  context = require('./context');

  render = require('./render');

  utils = require('./utils');

  unwrap = utils.string.unwrap;

  timing = {};

  describe = function(timing, counts) {
    var duration, rps;
    rps = utils.round(counts.rendered / (utils.elapsed(timing.render, timing.stop)), 2);
    duration = utils.elapsed(timing.start, timing.stop);
    if (counts.rendered) {
      console.log('');
    }
    console.log(unwrap("Processed " + (counts.rendered.toString().bold) + " pages. Skipped " + (counts.skipped.toString().bold) + " pages."));
    if (counts.rendered) {
      return console.log(unwrap("Rendered " + (rps.toString().bold) + " pages per second, took " + (duration.toString().bold) + " seconds in total."));
    }
  };

  module.exports = function(layoutPattern, outputPattern, contextEnum, globalsEnum, options, callback) {
    var contexts, globals, layoutTemplate, offenders, outputPlaceholders, outputTemplate, renderer, renderingOptions;
    timing.start = new Date();
    _.defaults(options, {
      key: 'items'
    });
    contexts = context.load(contextEnum);
    globals = context.load(globalsEnum);
    layoutTemplate = new PathExp(layoutPattern);
    if (outputPattern) {
      outputTemplate = new PathExp(outputPattern);
      outputPlaceholders = _.pluck(outputTemplate.placeholders, 'name');
    } else {
      outputTemplate = false;
      outputPlaceholders = [];
    }
    if (options.newerThan && typeof options.newerThan !== 'string') {
      options.newerThan = context.mtime([contextEnum, globalsEnum].join(','));
    }
    if (options.root) {
      contexts = utils.traverse(contexts, options.root);
    }
    if (options.pairs) {
      contexts = (_.pairs(contexts)).map(function(arg) {
        var key, value;
        key = arg[0], value = arg[1];
        return {
          key: key,
          value: value
        };
      });
    }
    if (!options.many) {
      contexts = [contexts];
    }
    if (globals) {
      contexts.forEach(function(context) {
        return _.defaults(context, globals);
      });
    }
    if (options.many && !options.fast) {
      offenders = groupby.clashes(contexts, outputPlaceholders);
      if (offenders.length) {
        offenders = offenders.join(', ');
        throw new Error(unwrap("Found more than one context set for " + offenders + ". Pick an output filename template that produces a unique filename for each set of context."));
      }
    }
    if (options.many) {
      if (!outputTemplate.hasPlaceholders) {
        throw new Error(unwrap("Rendering a collection requires an output filename template with placeholders, to avoid rendering each context set to the same file."));
      }
      if (contexts.constructor !== Array) {
        throw new Error("Rendering a collection requires input in the form of an array. If your data is an object, consider specifying --many-pairs.");
      }
    }
    renderingOptions = _.pick(options, 'engine', 'key', 'newerThan', 'force', 'verbose');
    _.extend(renderingOptions, {
      output: outputTemplate || false
    });
    renderer = function(context, callback) {
      return render(layoutTemplate, context, renderingOptions, callback);
    };
    timing.render = new Date();
    return async.mapSeries(contexts, renderer, function(err, operations) {
      var counts;
      timing.stop = new Date();
      counts = _.countBy(operations, _.identity);
      _.defaults(counts, {
        rendered: 0,
        skipped: 0
      });
      if (options.verbose) {
        describe(timing, counts);
      }
      return callback(err, counts);
    });
  };

}).call(this);
