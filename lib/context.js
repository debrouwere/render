// Generated by CoffeeScript 1.9.1
(function() {
  var _, async, confert, fs, merge, parsePaths, unwrap, utils,
    slice = [].slice;

  fs = require('fs');

  fs.path = require('path');

  async = require('async');

  _ = {
    compact: require('lodash.compact'),
    extend: require('lodash.assignin'),
    pick: require('lodash.pick'),
    pluck: require('lodash.pluck'),
    max: require('lodash.max')
  };

  confert = require('confert');

  utils = require('./utils');

  unwrap = utils.string.unwrap;

  parsePaths = function(paths, options) {
    var extension, extensionlessFilename, filename, i, len, namespace, path, ref, results, segments;
    if (paths == null) {
      paths = [];
    }
    if (options == null) {
      options = {};
    }
    ref = _.compact(paths.split(','));
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      path = ref[i];
      segments = path.split(':');
      filename = segments.pop();
      namespace = segments.pop();
      extension = fs.path.extname(path);
      if (!namespace) {
        if (options.fullyNamespaced) {
          extensionlessFilename = filename.slice(0, -extension.length);
          namespace = extensionlessFilename.replace(/\//g, '.');
        } else if (options.namespaced) {
          namespace = fs.path.basename(filename, extension);
        }
      }
      results.push({
        filename: filename,
        namespace: namespace
      });
    }
    return results;
  };

  merge = function() {
    var add, destination, i, len, source, sources;
    sources = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    for (i = 0, len = sources.length; i < len; i++) {
      source = sources[i];
      if (source.data.constructor === Array && source.namespace) {
        source.data = utils.kv(source.namespace, source.data);
        source.namespace = false;
      }
      if (typeof destination === "undefined" || destination === null) {
        switch (source.data.constructor) {
          case Array:
            destination = [];
            add = function(items) {
              return destination.push.apply(destination, items);
            };
            break;
          case Object:
            destination = {};
            add = function(hash) {
              return _.extend(destination, hash);
            };
            break;
          default:
            throw new Error(unwrap("Can only merge data from objects or arrays. Instead got: " + source.constructor));
        }
      }
      if (source.data.constructor !== destination.constructor) {
        throw new Error(unwrap("Mixed data types. Expected: " + destination.constructor.name + ". Instead got: " + source.constructor.name + "."));
      }
      if (destination.constructor === Object && source.namespace) {
        utils.set(destination, source.namespace, source.data);
      } else {
        add(source.data);
      }
    }
    return destination;
  };

  exports.load = function(pathList, options) {
    var extension, filename, i, len, namespace, path, paths;
    paths = parsePaths(pathList, _.pick(options, 'namespaced', 'fullyNamespaced'));
    if (!paths.length) {
      return {};
    }
    for (i = 0, len = paths.length; i < len; i++) {
      path = paths[i];
      filename = path.filename, namespace = path.namespace;
      extension = fs.path.extname(filename);
      path.data = confert(fs.path.resolve(filename));
    }
    return merge.apply(null, paths);
  };

  exports.mtime = function(pathList) {
    var mtimes, paths;
    paths = _.pluck(parsePaths(pathList), 'filename');
    mtimes = paths.map(fs.statSync).map(function(stats) {
      return stats.mtime;
    });
    return _.max(mtimes);
  };

}).call(this);
